#!/usr/bin/env python3
"""Switchmap-NG ingest cache daemon.

Extracts agent data from cache directory files.

"""

# Standard libraries
import time
import sys
import os
from multiprocessing import Pool
from collections import namedtuple

# Try to create a working PYTHONPATH
_SYS_DIRECTORY = os.path.dirname(os.path.realpath(__file__))
_BIN_DIRECTORY = os.path.abspath(os.path.join(_SYS_DIRECTORY, os.pardir))
_ROOT_DIRECTORY = os.path.abspath(os.path.join(_BIN_DIRECTORY, os.pardir))
if _SYS_DIRECTORY.endswith(
        '{0}switchmap-ng{0}bin{0}systemd'.format(os.sep)) is True:
    sys.path.append(_ROOT_DIRECTORY)
else:
    print(
        'This script is not installed in the "switchmap-ng{0}bin{0}systemd" '
        'directory. Please fix.'.format(os.sep))
    sys.exit(2)

# switchmap.libraries
try:
    from switchmap.core import log
except:
    print('You need to set your PYTHONPATH to include the switchmap library')
    sys.exit(2)
from switchmap import Config
from switchmap.core import general
from switchmap.db.table import event, IEvent
from switchmap.db.misc import disable
from switchmap.poll.update import device, topology
from switchmap.poll.snmp import poller
from switchmap.core.agent import Agent, AgentCLI, AgentAPI
from switchmap import AGENT_POLLER


# We have to create this named tuple outside the multiprocessing Pool
# for it to be pickled
_Poll = namedtuple('_Poll', 'hostname idx_event')


class PollingAgent(Agent):
    """Agent that gathers data."""

    def __init__(self, parent):
        """Initialize the class.

        Args:
            parent: Name of parent

        Returns:
            None

        """
        # Instantiate subclass
        Agent.__init__(self, parent)

        # Initialize key variables
        self.name = parent

        # Get configuration
        self._server_config = Config()

    def query(self):
        """Query all remote hosts for data.

        Args:
            None

        Returns:
            None

        """
        # Initialize key variables
        delay = self._server_config.polling_interval()
        ts_start = int(time.time())

        # Post data to the remote server
        while True:
            log_message = ('Starting device polling sequence.')
            log.log2info(1056, log_message)

            # Delete temporary topology directory files
            # temp_topology_directory = (
            #     self._server_config.temp_topology_directory())
            # if os.path.isdir(temp_topology_directory):
            #     general.delete_files(temp_topology_directory)

            # Poll after sleeping
            _poll_devices()

            # Create search files
            # tables.SearchFiles().create()

            # Modify temp yaml files to include IP address and
            # Delete permanent topology directory files
            # topology_directory = self._server_config.topology_directory()
            # if os.path.isdir(topology_directory):
            #     general.delete_files(topology_directory)
            #
            # # Move files to topology directory
            # general.move_files(
            #     temp_topology_directory, topology_directory)

            log_message = (
                'Completed device polling sequence. {}s duration'
                ''.format(int(time.time()) - ts_start))
            log.log2info(1125, log_message)

            # Sleep for "delay" seconds
            time.sleep(delay)


def _poll_devices():
    """Poll all devices for data using subprocesses and create YAML files.

    Args:
        None

    Returns:
        None

    """
    # Get configuration
    config = Config()
    _event = _create_event()

    # Get the number of threads to use in the pool
    threads_in_pool = config.agent_threads()

    # Create a list of polling objects
    hostnames = sorted(config.hostnames())

    for hostname in hostnames:
        _poll_single_device(
            _Poll(hostname=hostname, idx_event=_event.idx_event)
        )

    # # Create a pool of sub process resources
    # with Pool(processes=threads_in_pool) as pool:
    #
    #     # Create sub processes from the pool
    #     pool.map(_poll_single_device, hostnames)

    # Disable any unused devices and/or MAC addresses
    disable.post_poll_cleanup(_event.idx_event)


def _poll_single_device(poll):
    """Poll single device for data and create YAML files.

    Args:
        poll: _Poll object

    Returns:
        None

    """
    # Initialize key variables
    hostname = poll.hostname
    idx_event = poll.idx_event

    # Poll data for obviously valid hostnames (eg. "None" used in installation)
    if bool(hostname) is True:
        if isinstance(hostname, str) is True:
            if hostname.lower() != 'none':
                poll = poller.Poll(hostname)
                snmp_data = poll.query()

                # Process device data
                _device = device.Device(snmp_data)
                data = _device.process()

                # Update the database tables with polled data
                topology.process(data, idx_event)


def _create_event():
    """Get and event ID for the next polling cycle.

    Args:
        None

    Returns:
        result: Event ID that doesn't already exist

    """
    # Get configuration
    while True:
        _event = general.random_hash()
        exists = event.exists(_event)
        if bool(exists) is False:
            break

    # Return
    row = IEvent(
        event=_event,
        enabled=1
    )
    event.insert_row(row)
    result = event.exists(_event)
    return result


def main():
    """Start the switchmap.agent.

    Args:
        None

    Returns:
        None

    """
    # Check user
    general.check_user()

    # Get configuration
    agent_poller = PollingAgent(AGENT_POLLER)

    # Do control
    cli = AgentCLI()
    cli.control(agent_poller)


if __name__ == "__main__":
    main()
